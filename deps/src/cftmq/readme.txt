За основу берем STOMP 1.0 (необходимое нам подмножество ф-ций) и обертываем его в TLSv1 (на стороне сервера отдельный софт типа stunnel).
Для идентификации участников опционально используем клиентские X509 сертификаты в дополнение к login и passcode в STOMP идентификации.
Login должен содержать 12-ти значный код участника и должен совпадать с CN в сертификате (если используются).
STOMP используется и для взаимодействия процессингов и для взаимодействия транспортных модулей с процессингом, по сути они симметричны.
Если процессинг хочет отправить сообщение(я) другому процессингу он устанавливает с ним TCP соединение исходя из таблицы маршрутизации (host:port) если его еще нет,
идентифицируется и начинает последовательно отправлять сообщения для клиентов, обслуживаемых этим процесингом (или процессингом, стоящим за этим процессингом).
В то же время транспортный модуль, не имея интерфейса для входящих ообщений, может подключиться к процессингу и подписаться на очередь адресованных ему сообщений.
Как только клиент авторизуается и делает подписку ему сразу отгружаются все накопленные для него сообщения. В тот же коннект клиент может отправлять исходящие.
В качестве нашего расширения STOMP можем прикрутить дополнительные заголовки для ЭЦП транспортного уровня.

Все в рамках одного брокера путем указания идентификатора очереди - то, что записано в очередь A будет получено подписчиками которые на нее подписаны в рамках одного брокера.
Мы строим сеть таких брокеров и клиентов. За основу берем только протокол, сама же реализация брокера наша (транспорт и уровень ЭДО).

Процессинг состоит из:
- слоя безопасности (stunnel, vpn, каналообразующее оборудование)
- STOMP брокера cftmq (GPL, open source ? )
- модуля доставки к удаленным процессингам (форвардер)
- модуля маршрутизации и учета уровня ЭДО
- транспортных агентов клиентов процессинга

Брокер занимается контролем доступа к сети, коммутацией сообщений между очередями в рамках одного процессинга и обеспечивает надежное хранение сообщений подлежащих доставке.

Транспортные агенты имеют свои собственные учетные записи, подключаются к брокеру по протоколу STOMP и должны иметь роль "push". Данная роль позволяет им отправлять сообщения
в очередь INPUT и подписаться на единственную очередь, имя которой совпадает и именем учетной записи, под которой произошел вход в систему.
Все исходящие сообщения от отправителя обретают дополнительный заголовок "reply-to" с идентификатором временной приватной очереди что бы получатель в рамках брокера знал как
быстро связаться с отправителем. Так же брокер добавляет заголовок "source" по которому можно идентифицировать отправителя. Оба заголовка актуальны только в рамках одного брокера,
каждый брокер при пересылке их актуализирует. Так же отправитель не в состоянии их подменить.

Модуль уровня ЭДО тоже имеет свою учетную запись в своем процессинге, роль - "router". Возможно запустить несколько экземпляров для масштабирования системы и распределения нагрузки.
В рамках своих привелегий модуль уровня ЭДО может подписаться на сообщения в очереди INPUT и отправлять сообщения в очердь OUTPUT либо в очереди транспортных агентов.
При пересылке сообщений уровень ЭДО обязан добавить STOMP заголовок "relay-to", в котором указать идентификатор следующего в цепочке процессинга (возможно это конечный процессинг
получателя сообщения), по нему будет производиться дальнейшая маршрутизация. Если сообщение предназначено для клиента данного процессинга,
то после регистрации, валидации и преобразований сообщение должно быть помещено в локальную очередь, имя которой совпадает с идентификатором получателя.
Если сообщение необходимо отправить дальше, то ЭДО помещает сообщение в очередь OUTPUT - в этом случае наличие заголовка "relay-to" обязательно.
В качестве значение "relay-to" возможно использование константы "default" - маршрут по умолчанию.

Форвардер имеет свою учетную запись, роль - "pull", их может быть запущено несколько. Все что умеет форвардер - забирать сообщения из OUTPUT и исходя из заголовка message-for и
таблицы маршрутизации отправлять по протоколу STOMP сообщения в другие процессинги в очередь INPUT. Он должен уметь работать со слоем безопасности (например, поддерживать TLS),
должен иметь учетную запись в каждом peer-to-peer процессинге и иметь там роль "push". Форвардер только отправляет из локальной OUTPUT в удаленные INPUT - обратно ничего не забирает,
хотя такой сценарий тоже возможен. По факту отправки дальше (получение RECEIPT от удаленного процессинга) либо получения отказа (ERROR, например, из-за переполнения очереди)
форвардер сразу формирует обратное сообщение с квитанцией о доставке в очередь INPUT уровня ЭДО.
Сообщение имеет пустое тело и содержит два дополнительных заголовка: "ref" с значением поля "receipt" пересылаемого сообщения (назначает ЭДО) и "status" - Y или N.
При чтении сообщений из INPUT уровень ЭДО обязательно должен анализировать значение поля "source" т.к. квитанции допустимы только от форвардера, но никто не мешает
транспортному агенту отправить все что угодно в INPUT - права на это у него есть.


В наших реалиях в первом приближении будет так:
- Клиент а1 процессинга А хочет отправить сообщение клиенту б1 процессинга Б (оба имеют уникальный BIC).
- а1 и б2 подключены к своим процессингам, идентифицированы по сертификатам и каждый подписан на очередь, имя которой совпадает с его BIC.
- а1 шлет в свой процессинг новое сообщение где в качестве названия очереди будет INPUT, а в качестве получателя на уровне ЭДО будет указан BIC б1.
- А при успешном получении отвечает RECEIPTом, ищет по справочнику идентификатор процессинга которому принадлежит BIC б1.
- А помещает сообщение в очередь OUTPUT добавив заголовок to, содержащий BIC б1.
- Форвардер А ищет по справочнику идентификатор соседнего процессинга используемого для доставки сообщений для Б (это может быть как промежуточный узел,
    так и сразу Б если есть прямая связь), если нет записи, то выбираем процессинг по умолчанию.
- Форвардер А ищет по справочнику host:port, выбранного для доставки Х, процессинга и устанавливает с ним соединение, если его еще нет, и логинится туда
    (идентификация тоже по сертификату и логину паролю).
- Форвардер А шлет в процессинг Х таким же способом как это делал а1 сообщение для б1, в качестве очереди назначения так же INPUT (заголовок message-for сохраняется).
...
- Процессинг Б получил сообщение для б1, ответил ACKом, он понял что это сообщение для его клиента (есть справочник клиентов) и его не надо форвардить дальше.
- Если б1 уже подключен и подписан на соответствующую ему очередь, то собщение передается ему. Если не подключен, то оно ждет в очереди его появления в сети.

По пути следования сообщение (вложение) на уровне ЭДО обрастает маршрутной информацией (путь следования), собирает подписи промежуточных процессингов,
производит действия в биллингах, возможно пораждает новые сообщения (документы) и инкрементирует счетчик промежуточных узлов (для исключения зацикливания).
Вложение может иметь множество подписей подписантов и может быть зашифровано отправителем. Первый процессинг на пути сообщения производит валидацию документа
(все ли подписи собраны, есть ли у подписантов полномочия, есть ли в сети такой адресат и т.п.). На стыке двух процессингов и процессинга и транспортным модулем клиента могут ходить
транспортные ЭЦП для обеспечения целостности и безопасности на нижнем уровне (доп заголовок STOMP). Полагаю это избыточно т.к. есть TLS и клиентские сертификаты соседних хостов,
само же сообщение в любом случае по пути следования собирает ЭЦП всех процессингов на уровне ЭДО, при этом все эти процессинги хранят копии для разрешения спорных ситуаций.



Про персисты:
http://habrahabr.ru/post/125137/
LevelDB оптимизирована для массовых апдейтов, в которых изменяются многие ключи в большом адресном пространстве.
Это важное условие для эффективного обновления инвертированного индекса, который не помещается в оперативной памяти.
Библиотека распространяется под свободной лицензией BSD-типа.

http://leveldb.googlecode.com/svn/trunk/doc/benchmark.html

SQLite

Berkeley DB
http://stackoverflow.com/questions/7302268/berkeley-db-concurrent-queues

http://fallabs.com/kyotocabinet/
http://fallabs.com/kyotocabinet/spex.html
libkyotocabinet-dev
http://www.databaseskill.com/3713212/

http://leveldb.org/
libleveldb-dev          fast key-value storage library
It does not support transactions.  Writes (including batches) are atomic.  Consistency is up to you.  There is limited isolation support.  And durability is a configurable option.  If you want want full blown ACID transactions, you'll need to write a layer on top of LevelDB to do this (like what WebKit's IndexedDB does).
Partial writes are ignored.

InnoDB
libinnodb-dev           Embedded InnoDB Library
GPLv2
http://habrahabr.ru/post/57927/




Формат файла с пользователями:
USER  MD5(PASS) ROLE

USER1:40be4e59b9a2a2b5dffb918c0e86b3d7:PUSH
USER2:40be4e59b9a2a2b5dffb918c0e86b3d7:ROUTER
USER3:40be4e59b9a2a2b5dffb918c0e86b3d7:PULL

ROLE:
nolimit         без ограничений
restricted      отправка в INPUT, подписка на одноименную очередь и чтение из приватной очереди
pull            только подписка на OUTPUT и отправка в INPUT
proxy           отправка в INPUT, подписка на любую очередь кроме INPUT
router          подписка на INPUT, отправка в любые очереди кроме INPUT (в т.ч. приватные)
